2,
3,
1,
2,
2,
3,
3
)
Index = c("A1", "A1", "A2", "A2", "A3", "B1", "B2", "B2", "B3", "B3")
df = data.frame(ID, Month, Index, stringsAsFactors = FALSE)
df
df$Month <- as.factor(df$Month)
df
df %>%
group_by(ID, Month) %>%
summarise(count = n_distinct(Index)) %>% filter(count < 2) %>% droplevels()
%>%
group_by(id, yr_month) %>%
summarise(count = n_distinct(yr_month_day)) %>% filter(count < 28) %>% droplevels()
#' count the number of unique days when grouped by id and and month
short_months <- trk4 %>%
group_by(id, yr_month) %>%
summarise(count = n_distinct(yr_month_day)) %>% filter(count < 28) %>% droplevels()
short_months
df
ID = c(rep("X", 5), rep("B", 5))
Month = c(
1,
1,
2,
2,
3,
1,
2,
2,
3,
3
)
Index = c("X1", "X1", "X2", "X2", "X3", "X1", "X2", "X2", "X2", "X3")
df = data.frame(ID, Month, Index, stringsXsFXctors = FALSE)
df$Month <- as.factor(df$Month)
df
ID = c(rep("X", 5), rep("B", 5))
Month = c(
1,
1,
2,
2,
3,
1,
2,
2,
3,
3
)
Index = c("X1", "X1", "X2", "X2", "X3", "X1", "X2", "X2", "X2", "X3")
df = data.frame(ID, Month, Index, stringsasFactors = FALSE)
df$Month <- as.factor(df$Month)
df
ID = c(rep("X", 5), rep("B", 5))
Month = c(
1,
1,
2,
2,
3,
1,
2,
2,
3,
3
)
Index = c("X1", "X1", "X2", "X2", "X3", "X1", "X2", "X2", "X2", "X3")
df = data.frame(ID, Month, Index, stringsAsFactors =  FALSE)
df$Month <- as.factor(df$Month)
df
ID = c(rep("A", 5), rep("B", 5))
Month = c(
1,
1,
2,
2,
3,
1,
2,
2,
3,
3
)
Index = c("X1", "X1", "X2", "X2", "X3", "X1", "X2", "X2", "X2", "X3")
df = data.frame(ID, Month, Index, stringsAsFactors =  FALSE)
df$Month <- as.factor(df$Month)
df
ID = c(rep("A", 5), rep("B", 5))
Month = c(
1,
1,
2,
2,
3,
1,
2,
2,
3,
3
)
Index = c("X1", "X1", "X2", "X2", "X3", "X1", "X2", "X2", "X2", "X3")
df = data.frame(ID, Month, Index, stringsAsFactors =  FALSE)
df$Month <- as.factor(df$Month)
df
df %>%
group_by(ID, Month) %>%
summarise(count = n_distinct(Index)) %>% filter(count < 2) %>% droplevels()
df %>%
group_by(ID, Month) %>%
summarise(count = n_distinct(Index)) %>% filter(count < 2) %>% droplevels()
df
df %>%
group_by(ID, Month)
head(trk4)
short_months
test <- merge(short_months, trk4, c(id, yr_month))
head(trk4)
short_months
id
test <- merge(short_months, trk4, c("id", "yr_month"))
test
rm(test)
head(trk4)
short_months
complete(trk4, id, yr_month) %>%
inner_join(., short_months)
test<- complete(trk4, id, yr_month) %>%
inner_join(., short_months)
min(test$count)
if_else(trk4$yr_month=short_months$yr_month,short_months$count, 0)
if_else(trk4$yr_month==short_months$yr_month,short_months$count, 0)
short_months
trk4 %>%
group_by(id, yr_month) %>%
summarise(count = n_distinct(yr_month_day))
merge(short_months, trk4)
merge(short_months, trk4, ALL = TRUE)
merge(short_months, trk4, all = TRUE)
test <- merge(short_months, trk4, all = TRUE)
length(test$id)
length(trk$id)
length(trk4$id)
filter(test, count == "NA")
filter(test, count == NA)
filter(test, count = NA)
test %>% filter_all(any_vars(is.na(.)))
#' keep only the rows with the NAs which are the counts > 28
trk5<- test %>% filter_all(any_vars(is.na(.)))
#' now create a unique identifier that has the ID, year and month
#' We will use these to build home ranges
trk5$identifier <- paste(trk5$id, trk5$yr_month, sep = "_")
trk5$identifier <- as.factor(trk5$identifier)
head(trk5)
#' run some summary stats on the data to make sure everything looks okay
length(levels(as.factor(trk5$id)))
length(levels(as.factor(trk5$id)))
sapply(split(trk5$x_, trk5$identifier), length)
#' Calculate home range size
#' first for MCP
mcps <- trk5 %>% group_by(identifier) %>%  nest(-identifier) %>%
mutate(mcparea = map(data, ~ hr_mcp(., levels = c(0.95)) %>% hr_area)) %>%
select(identifier, mcparea) %>% unnest()
mcps$area <- mcps$area / 1000000
#' Calculate home range size
#' first for MCP
mcps <- trk5 %>% group_by(identifier) %>%  nest(-identifier) %>%
mutate(mcparea = map(data, ~ hr_mcp(., levels = c(0.95)) %>% hr_area)) %>%
select(identifier, mcparea) %>% unnest()
#' turn it back into a trk
trk5 <-
mk_track(
trk5,
.x = x,
.y = y,
.t = date,
id = ID,
crs = CRS(
"+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +units=m +no_defs"
)
)
trk5
head(trk5)
head(trk4)
#' count the number of unique days when grouped by id and and month
short_months <- trk4 %>%
group_by(id, yr_month) %>%
summarise(count = n_distinct(yr_month_day)) %>% filter(count < 28) %>% droplevels()
short_months
short_months$yr_month
#' we merge the two and force all = TRUE so even the values that don't have a count
#' are included, this allows us to extract the tracks we won't that have ~ a month
#' of coverage
test <- merge(short_months, trk4, all = TRUE)
length(test$id)
length(trk4$id)
#' keep only the rows with the NAs which are the counts > 28
trk5<- test %>% filter_all(any_vars(is.na(.)))
#' now create a unique identifier that has the ID, year and month
#' We will use these to build home ranges
trk5$identifier <- paste(trk5$id, trk5$yr_month, sep = "_")
trk5$identifier <- as.factor(trk5$identifier)
head(trk5)
head(trk3)
head(trk5)
head(trk5)
trk5 <-
mk_track(
trk5,
.x = x_,
.y = y_,
.t = t_,
id = id,
crs = CRS(
"+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +units=m +no_defs"
)
)
#' run some summary stats on the data to make sure everything looks okay
length(levels(as.factor(trk5$id)))
length(levels(as.factor(trk5$id)))
sapply(split(trk5$x_, trk5$identifier), length)
trk5
trk4
#' now create a unique identifier that has the ID, year and month
#' We will use these to build home ranges
trk5$identifier <- paste(trk5$id, trk5$yr_month, sep = "_")
#' we merge the two and force all = TRUE so even the values that don't have a count
#' are included, this allows us to extract the tracks we won't that have ~ a month
#' of coverage
test <- merge(short_months, trk4, all = TRUE)
length(test$id)
length(trk4$id)
#' keep only the rows with the NAs which are the counts > 28
trk5<- test %>% filter_all(any_vars(is.na(.)))
#' now create a unique identifier that has the ID, year and month
#' We will use these to build home ranges
trk5$identifier <- paste(trk5$id, trk5$yr_month, sep = "_")
trk5$identifier <- as.factor(trk5$identifier)
head(trk5)
#' turn it back into a trk
trk5 <-
mk_track(
trk5,
.x = x_,
.y = y_,
.t = t_,
id = id,
crs = CRS(
"+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +units=m +no_defs"
)
)
trk5
#' keep only the rows with the NAs which are the counts > 28
trk5<- test %>% filter_all(any_vars(is.na(.)))
#' now create a unique identifier that has the ID, year and month
#' We will use these to build home ranges
trk5$identifier <- paste(trk5$id, trk5$yr_month, sep = "_")
trk5$identifier <- as.factor(trk5$identifier)
head(trk5)
trk5 <-
mk_track(
trk5,
.x = x_,
.y = y_,
.t = t_,
id = id,
identifier = identifier,
crs = CRS(
"+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +units=m +no_defs"
)
)
trk5
#' run some summary stats on the data to make sure everything looks okay
length(levels(as.factor(trk5$id)))
length(levels(as.factor(trk5$id)))
sapply(split(trk5$x_, trk5$identifier), length)
#' Calculate home range size
#' first for MCP
mcps <- trk5 %>% group_by(identifier) %>%  nest(-identifier) %>%
mutate(mcparea = map(data, ~ hr_mcp(., levels = c(0.95)) %>% hr_area)) %>%
select(identifier, mcparea) %>% unnest()
mcps$area <- mcps$area / 1000000
mcp_95 <- mcps %>% arrange(identifier)
mcp_95
#' Same for KDE 95
kde <- trk5 %>% group_by(identifier) %>% nest(-identifier) %>%
mutate(kdearea = map(data, ~ hr_kde(., level = c(0.95)) %>% hr_area)) %>%
select(identifier, kdearea) %>% unnest()
kde$kdearea <-  kde$kdearea / 1000000
kde_95 <- kde %>% arrange(identifier)
kde_95
#' combine the data
kde_95$mcp <- mcp_95$area
#' rename
home_range_month <- kde_95
head(home_range_month)
tail(home_range_month)
#' add an id column
home_range_month <-
separate(
home_range_month,
col = identifier,
into = c("id", "NA"),
sep = "_",
remove = "FALSE"
) %>%  select(-"NA")
home_range_month
filter(home_range_month, id == 768)
#' export the results
write.csv(home_range_month, "results/home_range_month.csv", row.names = F)
#'##########################################################################
#' ame1 project - studying the relation between home range size and activity
#' 2019/11/04
#' Adam Kane, Enrico Pirotta & Barry McMahon
#' https://mecoco.github.io/ame1.html
#' summarise the covariates
############################################################################
library(adehabitatLT)
library(lubridate)
library(amt)
library(sp)
#' can filter by study for testing
#'  mydata <- filter(mydata, study_areas_id == "1")
#' Check for duplicated observations
ind2 <-
mydata %>% select(acquisition_time, longitude, latitude, animals_id) %>%
duplicated
sum(ind2)
# remove them
mydata$dups <- ind2
mydata <- filter(mydata, dups == "FALSE")
mydata
rm(ind2)
#' rename some of the columns for data manipulation
#' order is new name old name
mydata <- rename(mydata, time = acquisition_time)
mydata <- rename(mydata, long = longitude)
mydata <- rename(mydata, lat = latitude)
mydata <- rename(mydata, id = animals_id)
mydata <- rename(mydata, study = study_areas_id)
mydata <- rename(mydata, ndvi = ndvi_modis_boku)
mydata <- rename(mydata, altitude = altitude_copernicus)
mydata <- rename(mydata, slope = slope_copernicus)
mydata <- rename(mydata, aspect = aspect_copernicus)
mydata <- rename(mydata, tree = treecover_copernicus)
#' all of the data is in the format of day-month-year
#' note that time is in UTC
mydata$New_time <-
parse_date_time(x = mydata$time, c("%Y-%m-%d %H:%M:%S"))
#'##########################################################################
#' ame1 project - studying the relation between home range size and activity
#' 2019/10/04
#' Adam Kane, Enrico Pirotta & Barry McMahon
#' https://mecoco.github.io/ame1.html
#' loading and cleaning the GPS data
############################################################################
#' Load the required packages
library(tidyverse)
#' Section 1: Load the data ----
mydata <- read_csv("data/gpsdata_mecoco.csv" , col_names = TRUE)
#' take a look at what we've loaded
glimpse(mydata)
head(mydata)
tail(mydata)
summary(mydata)
str(mydata)
levels(as.factor(mydata$animals_id))
#' 1,892,424 observations of 15 variables
#' looks like there are some NAs in the data
#' let's drop them
mydata <- mydata %>% drop_na()
#' reduces the data set down to 1,788,743 observations
#' how many data points are in each of the studies?
mydata %>% group_by(study_areas_id) %>% summarise(duration = length(study_areas_id))
#'##########################################################################
#' ame1 project - studying the relation between home range size and activity
#' 2019/11/04
#' Adam Kane, Enrico Pirotta & Barry McMahon
#' https://mecoco.github.io/ame1.html
#' summarise the covariates
############################################################################
library(adehabitatLT)
library(lubridate)
library(amt)
library(sp)
#' can filter by study for testing
#'  mydata <- filter(mydata, study_areas_id == "1")
#' Check for duplicated observations
ind2 <-
mydata %>% select(acquisition_time, longitude, latitude, animals_id) %>%
duplicated
sum(ind2)
# remove them
mydata$dups <- ind2
mydata <- filter(mydata, dups == "FALSE")
mydata
rm(ind2)
#' rename some of the columns for data manipulation
#' order is new name old name
mydata <- rename(mydata, time = acquisition_time)
mydata <- rename(mydata, long = longitude)
mydata <- rename(mydata, lat = latitude)
mydata <- rename(mydata, id = animals_id)
mydata <- rename(mydata, study = study_areas_id)
mydata <- rename(mydata, ndvi = ndvi_modis_boku)
mydata <- rename(mydata, altitude = altitude_copernicus)
mydata <- rename(mydata, slope = slope_copernicus)
mydata <- rename(mydata, aspect = aspect_copernicus)
mydata <- rename(mydata, tree = treecover_copernicus)
#' all of the data is in the format of day-month-year
#' note that time is in UTC
mydata$New_time <-
parse_date_time(x = mydata$time, c("%Y-%m-%d %H:%M:%S"))
# keep only the new time data
mydata <- select(mydata, New_time, long, lat, id, study, ndvi, altitude, slope, aspect, tree, corine_2006, corine_2012)
mydata <- rename(mydata, time = New_time)
mydata
#' we want to work with monthly averages
#' some animals were tracked for over a year
#' so we must include a year-month-id grouping variable
#' first combine year and month
mydata$yr_month <- format(mydata$time, format = "%Y/%m")
mydata$yr_month  <- as.factor(mydata$yr_month)
#' we also need a year-month-day variable to see what the coverage is like over the course of
#' a month for each individual
mydata$yr_month_day <- format(mydata$time, format = "%Y/%m/%d")
mydata$yr_month_day <- as.factor(mydata$yr_month_day)
head(mydata)
#' count the number of unique days when grouped by id and and month
short_months <- mydata %>%
group_by(id, yr_month) %>%
summarise(count = n_distinct(yr_month_day)) %>% filter(count < 28) %>% droplevels()
short_months
short_months$yr_month
#' we merge the two and force all = TRUE so even the values that don't have a count
#' are included, this allows us to extract the tracks we won't that have ~ a month
#' of coverage
mydata2 <- merge(short_months, mydata, all = TRUE)
length(mydata$id)
length(mydata2$id)
#' keep only the rows with the NAs which are the counts > 28
mydata2<- mydata2 %>% filter_all(any_vars(is.na(.)))
head(mydata2)
max(mydata2$count, na.rm = T)
#' Corine data switches in 2012, so they're not the same value
#' mydata2$corine_2006 == mydata2$corine_2012
#' We can create a new column with year and provide Corine conditional on the year
mydata2$year <- format(mydata2$time, format = "%Y")
mydata2$year <- as.numeric(mydata2$year)
head(mydata2)
mydata2$corine <- if_else(mydata2$year >= 2012, mydata2$corine_2012, mydata2$corine_2006)
#' check that it worked
mydata2 %>% filter(id == 1453)
#' now create a unique identifier that has the ID, year and month
#' We will use these to summarise the covariates
mydata2$identifier <- paste(mydata2$id, mydata2$yr_month, sep = "_")
mydata2$identifier <- as.factor(mydata2$identifier)
head(mydata2)
#' Create the function for mode
getmode <- function(v) {
uniqv <- unique(v)
uniqv[which.max(tabulate(match(v, uniqv)))]
}
#' calculate summary statistics for each covariate
summary_data <- mydata2 %>% group_by(identifier) %>%
summarise_at(.vars = vars(ndvi, altitude, slope, aspect, tree, corine),
.funs = c(Mean="mean", Sd="sd", Median = "median", Mode = "getmode"))
#' remove the summary statistics for corine that don't make sense i.e. everything bar the mode
summary_data <- summary_data %>% select(-corine_Mean, -corine_Sd, -corine_Median)
summary_data
write.csv(summary_data, "results/env_data.csv", row.names = F)
#' export the results
write.csv(summary_data, "results/env_data.csv", row.names = F)
#' add an id column
summary_data <-
separate(
summary_data,
col = identifier,
into = c("id", "NA"),
sep = "_",
remove = "FALSE"
) %>%  select(-"NA")
#' export the results
write.csv(summary_data, "results/env_data.csv", row.names = F)
#' load in Enri's data
activity <- read_csv("results/Activity_data_byMonth.csv" , col_names = TRUE)
#' load in HR data
hr <- read_csv("results/home_range_month.csv" , col_names = TRUE)
#' load in environmental data
env <- read_csv("results/env_data.csv" , col_names = TRUE)
head(env)
merge1 <- merge(hr,env,c("identifier")) %>% select(-id.x, -id.y)
head(merge1)
#' make an identifier so it matches the other output
#' add a leading zero
activity$month <- sprintf("%02d",activity$month) # fix to 2 characters
activity$yr_month <- paste(activity$year, activity$month, sep = "/")
activity$identifier <- paste(activity$animals_id, activity$yr_month, sep = "_")
activity <- activity %>% select(-yr_month)
head(activity)
all_data <- merge(merge1,activity,c("identifier")) %>% select(-id.x, -id.y)
all_data <- merge(merge1,activity,c("identifier"))
head(all_data)
length(all_data$identifier)
#' export the results
write.csv(all_data, "results/combined_data.csv", row.names = F)
short_months
